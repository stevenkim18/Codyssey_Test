## 보너스

https://www.docker.com/resources/what-container/

### 가상머신과 컨테이너의 차이

가상머신(Virtual Machine, VM)

- 하나의 물리적인 컴퓨터에서 또 다른 가상 컴퓨터를 만들어서 OS를 구동시키기 위한 기술
- 일반적인 사용자는 다른 OS을 사용하기 위해 많이 사용
    - 윈도우 → 리눅스, 맥
    - 맥 → 리눅스, 윈도우
- 다른 OS에서 테스트를 해야되거나, 서버 환경을 테스트 할 때 많이 사용됨.
- 특징은 물리 컴퓨터의 리소스(램, 디스크)를 일부 할당할 수 있고, 별도 **독립적**으로 운영이 가능
- 사용하려면 Hypervisor 엔진을 사용한 프로그램이 필요(VMware, VirtualBox)

컨테이너

- 공식 문서 정의 - 코드와 모든 종속성을 패키징하여 애플리케이션이 한 컴퓨팅 환경에서 다른 환경으로 빠르고 안정적으로 실행되도록 하는 표준 소프트웨어 단위
    - 별도의 어플리케이션(보통은 flask같은 웹앱)이 실행되는 작은 독립된 공간
    - 우리가 어떤 프로그램을 실행하기 위해서 여러개 프로그램을 설치해야 되는데 이것이 미리 패키지 되어 있어, 쉽게 다른 컴퓨터에서도 한 번에 실행할 수 있음.
- Host OS의 자원을 공유함.
    - 가상머신은 리소스를 사용자가 설정에서 할당을 해줘야 함.
    - 반대로 컨테이너는 프로그램의 의해 리소스를 공유함.

가상머신과 컨테이너의 차이

- 가상머신은 집 전체, 컨테이너는 방으로 비유할 수 있음.
- 가상머신은 집 전체이기 때문에, 독립적이고 무거움
- 컨테이너는 방이기 떄문에, 집의 리소스를 공유하고, 가벼움.

| 구분 | 🖥 가상머신 (Virtual Machine) | 📦 컨테이너 (Container) |
| --- | --- | --- |
| **정의** | 가상의 컴퓨터를 소프트웨어로 구현한 것 | 앱을 실행하기 위한 모든 것을 담은 독립 실행 공간 |
| **구성 요소** | 하이퍼바이저 + 게스트 OS + 앱 | 컨테이너 엔진 + 앱 + 라이브러리 |
| **운영체제 포함 여부** | **게스트 OS 포함** (전체 OS) | **게스트 OS 없음**, 호스트 OS 공유 |
| **실행 속도** | 느림 (수십 초~수 분) | 빠름 (거의 즉시 실행) |
| **용량/무게** | 무거움 (수 GB 이상) | 가벼움 (수 MB ~ 수백 MB) |
| **시작 방식** | 운영체제부터 부팅 | 앱만 실행하면 됨 |
| **격리 수준** | 강력한 격리 (완전히 분리된 OS) | 프로세스 단위 격리 (비교적 약함) |
| **성능** | 약간 느릴 수 있음 (오버헤드 있음) | 거의 네이티브 성능 |
| **운영체제 다양성** | 윈도우 위에 리눅스, 리눅스 위에 윈도우 가능 | 호스트 OS와 같은 커널 사용해야 함 |
| **사용 예시** | 윈도우에서 리눅스 서버 테스트 | 서버에 앱 빠르게 배포, 마이크로서비스 실행 |
| **대표 도구** | VMware, VirtualBox, Hyper-V | Docker, Podman, containerd |

### 컨테이너와 이미지의 차이

![image.png](attachment:058c90e1-388f-4bd1-877f-5603d8248b52:image.png)

이미지

- 컨테이너를 만들기 위한 설명서이자 탬플릿
    - 앱을 실행하기 위한 프로그램, 소스코드, 설정등을 담고 있음.
- 읽기 전용(수정 불가)
- 한개의 이미지로 여러개의 컨테이너를 만들 수 있음.

이미지와 컨테이너

- 비유로 설명하면, 이미지가 방 설계도라면, 컨테이너는 여러개의 방
- 이미지가 레시피라면 컨테이너는 레시피를 가지고 만들어진 음식들..

### 컨테이너 런타임의 정의

- 이미지는 레시피, 컨테이너는 음식이라면 런타임은 요리를 하는 요리사
- 실제로 이미지를 읽고, 컨테이너를 생성하고 실행 중지 등을 함.
- Docker는 runc, containerd이라는 런타임을 내부적으로 사용
    - runc는 저수준 런타임 - 실제 리눅스 커널에 접근해 컨테이너 생성하고 수행하는 기능을 담당
    - containerd는 고수준 런타임 - 저수준 런타임 위에 있고 컨테이너를 관리하고 설정등을 담당,

```bash
Docker 명령어 입력
     ↓
Docker Engine (containerd)
     ↓
runc
     ↓
컨테이너 실행
```

### CNCF란

https://landscape.cncf.io/

- **CNCF** = *Cloud Native Computing Foundation*
- 클라우드 네이티브 기술(예: Kubernetes, Prometheus, Envoy 등)을 개발·보급하는 오픈소스 재단
- 리눅스 재단(Linux Foundation) 산하에 있고, 전 세계 IT 기업들이 참여

### 컨테이너 런타임의 3가지 종류

`runc`

- 저수준 런타임의 사실상 표준
- namespace와 cgroup을 설정 및 구성하여 작업을 수행,
- 컨테이너를 생성하고 실행하는 기능을 담당.

`containerd`

- docker 재단에서 만든 고수준 런타임
- 가장 많이 쓰이고, Docker Engine에도 탑재

`CRI-O`

- RadHat 주관, 고수준 런타임
- Kubernetes 전용 런타임

### 도커의 이미지 레이어란

- 이미지는 컴퓨터를 실행하기 위한 압축 파일
- 이미지 안에 있는 요소들을 효과적으로 저장하기 위한 계층이 이미지 레이어
- 방을 만들 때, 기초 공사 → 뼈대 → 내부 → 마감을 하듯이 이미지도 이와 같은 과정을 거침
- 효율적으로 저장이 되어 속도가 빠름.

```docker
FROM ubuntu:20.04          # 레이어 1: 베이스 이미지
RUN apt-get update         # 레이어 2: 패키지 목록 업데이트
RUN apt-get install -y nginx  # 레이어 3: nginx 설치
COPY index.html /var/www/html/  # 레이어 4: 파일 복사
CMD ["nginx", "-g", "daemon off;"]  # 레이어 5: 실행 명령
```

```bash
┌─────────────────────────────────┐
│        CMD nginx                │ ← 레이어 5 (메타데이터)
├─────────────────────────────────┤
│        COPY index.html          │ ← 레이어 4 (파일 추가)
├─────────────────────────────────┤
│        RUN install nginx        │ ← 레이어 3 (패키지 설치)
├─────────────────────────────────┤
│        RUN apt-get update       │ ← 레이어 2 (패키지 업데이트)
├─────────────────────────────────┤
│        FROM ubuntu:20.04        │ ← 레이어 1 (베이스 이미지)
└─────────────────────────────────┘
```

### 참고 자료

- [https://khj93.tistory.com/entry/Docker-Docker-개념](https://khj93.tistory.com/entry/Docker-Docker-%EA%B0%9C%EB%85%90)
- https://osckorea.tistory.com/189
- https://creboring.net/blog/how-docker-divide-image-layer/